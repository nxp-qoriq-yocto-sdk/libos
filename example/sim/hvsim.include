#
# Script to run 8578/u-boot/ultravisor on simulator
#

# display options
digit-grouping 16 8
output-radix 16

if not defined uboot		{$uboot  = "u-boot.4080"}
if not defined kernel_image	{$kernel_image  = "%script%/bin/hv.uImage"}
if not defined kernel_addr      {$kernel_addr   = 0x40000}
if not defined kernel_symbols	{$kernel_symbols = ""}
if not defined uboot_symbols	{$uboot_symbols = ""}
if not defined dtb_image	{$dtb_image  = "%script%/bin/mpc8578sim-hv.dtb"}
if not defined flash_base	{$flash_base   = 0xe8000000}
if not defined dtb_flash_offset	{$dtb_flash_offset   = 0x20000}
if not defined dtb_ram_addr	{$dtb_ram_addr  = 0x00f00000}
if not defined dtb_size		{$dtb_size  = 0x00100000}
if not defined use_uart0	{$use_uart0 = 1}
if not defined use_uart1	{$use_uart1 = 0}
if not defined use_uart2	{$use_uart2 = 1}
if not defined use_uart3	{$use_uart3 = 0}
if not defined do_boot		{$do_boot = "yes"}
if not defined create_network  {$create_network = "yes"}
if not defined host_name	{$host_name   = "MPC8578-simple"}
if not defined system_info	{$system_info = $host_name + " - Linux 2.6.x (IP " + $ip_address + ")" }
if not defined guest_image	{$guest_image = ""}
if not defined boot_command  {$boot_command  = "bootm 0xe8040000 - 0x00f00000"}
if not defined mac_address   {$mac_address   = "00:01:af:07:9b:8a"}
if not defined mac_address1  {$mac_address1  = "00:01:af:07:9b:8b"}
if not defined mac_address2  {$mac_address2  = "00:01:af:07:9b:8c"}
if not defined mac_address3  {$mac_address3  = "00:01:af:07:9b:8d"}
if not defined ip_address    {$ip_address    = "10.10.0.80"}
if not defined ip_address1   {$ip_address1   = "10.10.0.81"}
if not defined ip_address2   {$ip_address2   = "10.10.0.82"}
if not defined ip_address3   {$ip_address3   = "10.10.0.83"}
if not defined service_node  {}
if not defined kernel_cmdline {$kernel_cmdline = "console=ttyS0,115200 simicsfs=0xeff00000"}

sim->handle_outside_memory = 1
add-directory "%script%" -prepend
add-directory "%script%/images/" -prepend


@def hap_callback(user_arg, cpu, arg):
	if arg == 21:
		SIM_break_simulation("end of run-- hit spin loop")
	elif arg == 22:
		SIM_break_simulation("trap()-- unknown exception")

if $want_magic_inst == 1 {
@SIM_hap_add_callback("Core_Magic_Instruction", hap_callback, None)
}

###

if not defined freq_mhz      {$freq_mhz      = 30}
if not defined sysclk_frequency {$sysclk_frequency = 5}
if not defined memory_megs   {$memory_megs   = 2048}
if not defined cpu_cores     {$cpu_cores     = 8}
###

load-module p4080-components
load-module memory-components
load-module std-components
load-module phy-components

$system = (create-simple-P4080-board cpu_cores = $cpu_cores
                                       sysclk_frequency = $sysclk_frequency
                                       cpu_frequency = $freq_mhz)

if $use_uart0 == 1 {
	$con1 = (create-std-text-console)
	$system.connect uart0 $con1
	# Terminal color & font, optionally settable
	if defined terminal_bg_color   {$con1->bg_color   = $terminal_bg_color}
	if defined terminal_fg_color   {$con1->fg_color   = $terminal_fg_color}
	if defined terminal_win32_font {$con1->win32_font = $terminal_win32_font}
	if defined terminal_x11_font   {$con1->x11_font   = $terminal_x11_font}
}

if $use_uart1 == 1 {
	$con2 = (create-std-text-console)
	$system.connect uart1 $con2
	# Terminal color & font, optionally settable
	if defined terminal_bg_color   {$con2->bg_color   = $terminal_bg_color}
	if defined terminal_fg_color   {$con2->fg_color   = $terminal_fg_color}
	if defined terminal_win32_font {$con2->win32_font = $terminal_win32_font}
	if defined terminal_x11_font   {$con2->x11_font   = $terminal_x11_font}
}

if $use_uart2 == 1 {
	$con3 = (create-std-text-console)
	$system.connect uart2 $con3
	# Terminal color & font, optionally settable
	if defined terminal_bg_color   {$con3->bg_color   = $terminal_bg_color}
	if defined terminal_fg_color   {$con3->fg_color   = $terminal_fg_color}
	if defined terminal_win32_font {$con3->win32_font = $terminal_win32_font}
	if defined terminal_x11_font   {$con3->x11_font   = $terminal_x11_font}
}

if $use_uart2_tty == 1 {
	$con3_tty = (create-std-host-serial-console)
	$system.connect uart2 $con3_tty
}

if $use_uart1_net == 1 {
	$con2_tty = (create-std-server-console "foo" 9124)
	$system.connect uart1 $con2_tty
}

if $use_uart2_net == 1 {
	$con3_tty = (create-std-server-console "foo" 9999)
	$system.connect uart2 $con3_tty
}

if $use_uart3 == 1 {
	$con4 = (create-std-text-console)
	$system.connect uart3 $con4
	# Terminal color & font, optionally settable
	if defined terminal_bg_color   {$con4->bg_color   = $terminal_bg_color}
	if defined terminal_fg_color   {$con4->fg_color   = $terminal_fg_color}
	if defined terminal_win32_font {$con4->win32_font = $terminal_win32_font}
	if defined terminal_x11_font   {$con4->x11_font   = $terminal_x11_font}
}

# Create ethernet PHYs and connect them to the MACs
foreach $phy_idx in (range 4) {
        # Create a generic MII transceiver identified as a Marvell 88E1011S
        $phy[$phy_idx] = (create-phy-mii-transceiver phy_id = 0x01410c60
                                                     mii_address = $phy_idx)
        $system.connect (etsec-phy + $phy_idx) $phy[$phy_idx]
}

# setup CS0/CS1 on DDR2 w/1G and CS0/1 on DDR2 w/1G
(create-and-connect-ddr-memory $system $memory_megs "A-A-"
                               ranks_per_module = 2
			       max_module_size = 2048
			       ddr_type = DDR2)

# Pulls in the create-pci commands
load-module pci-components

# Create and connect a SIL controller with a single IDE disk to the first
# PCIe interface
#$sil = (create-pci-sil680a)
#$disk = (create-std-ide-disk size = (80 * 1024 * 1024 * 1024))
#$sil.connect ide0-slot0 $disk
#$system.connect pcie0-slot0 $sil

instantiate-components

cpu0->compat_magic = FALSE

# work arounds

$eth_comp = $phy[0]
if not defined eth_cnt { $eth_cnt = eth }
run-command-file "%simics%/targets/common/add-eth-link.include"

$console = $con1

###
$system->system_info = $system_info

if $service_node {
    local $sn = ($service_node:sn)
    ($sn.add-host name = $host_name
                         ip = $ip_address domain = network.sim
                         mac = $mac_address)
}

default-port-forward-target $ip_address

$phys_mem = ($system:phys_mem)
$phys_mem.load-file $uboot 0xfff80000

if ($kernel_image != "") {
	flash_space.load-file $kernel_image $kernel_addr
}

if ($dtb_image != "") {
	flash_space.load-file $dtb_image $dtb_flash_offset
}

# U-boot uses l1 cache without backing RAM
# the address has to match u-boot build/config
($phys_mem.add-map
        ($system:l1_cache)
        base = 0xfdd00000 length = 0x4000
        priority = 200 offset = 0xfdd00000)

# U-boot symbols
if $uboot_symbols != "" {
        local $syms = (lookup-file $uboot_symbols)
        new-symtable uboot file = $syms
}

# Kernel symbols
if $kernel_symbols != "" {
        local $syms = (lookup-file $kernel_symbols)
        new-symtable kernel file = $syms
}

if $do_boot == "yes" {
    script-branch {
	local $con          = ($console:con)
        local $phys_mem     = ($system:phys_mem)

#        local $kernel_image = $kernel_image
#        local $kernel_addr  = $kernel_addr
        local $boot_command = $boot_command
        local $cmdline      = $kernel_cmdline
        local $mac_address  = $mac_address
        local $mac_address1 = $mac_address1
        local $mac_address2 = $mac_address2
        local $mac_address3 = $mac_address3
        local $ip_address   = $ip_address
        local $ip_address1  = $ip_address1
        local $ip_address2  = $ip_address2
        local $ip_address3  = $ip_address3
        local $dtb_flash_offset     = $dtb_flash_offset
        local $dtb_image    = $dtb_image

        $con.wait-for-string "autoboot:"
        $con.input "\n"

        # u-boot does not read the MAC from the PHY, but reads them directly
        # from it's environment variables.

        # First ethernet interface
        $con.wait-then-write "=> " "setenv ethaddr " + $mac_address + "\n"
        $con.wait-then-write "=> " "setenv ipaddr " + $ip_address + "\n"

        # Looks like u-boot does not set MAC1-3 correctly

        # Second ethernet interface
        $con.wait-then-write "=> " "setenv eth1addr " + $mac_address1 + "\n"
        $con.wait-then-write "=> " "setenv ip1addr " + $ip_address1 + "\n"

        # Third ethernet interface
        $con.wait-then-write "=> " "setenv eth2addr " + $mac_address2 + "\n"
        $con.wait-then-write "=> " "setenv ip2addr " + $ip_address2 + "\n"

        # Fourth, and last, ethernet interface
        $con.wait-then-write "=> " "setenv eth3addr " + $mac_address3 + "\n"
        $con.wait-then-write "=> " "setenv ip3addr " + $ip_address3 + "\n"

        if $service_node {
                $con.wait-then-write "=> " "setenv gatewayip 10.10.0.1\n"
                $con.wait-then-write "=> " "setenv serverip 10.10.0.1\n"
        }

        if ($cmdline != "") {
            $con.wait-then-write "=> " "setenv bootargs " + $cmdline + "\n"
        }

	# Work-around for QMAN FDQ transactions accessing portal DLIODNs
	# instead of QMAN_LIODNR,program all s/w portal DLIODNs to QMAN_LIODNR
	$phys_mem.set 0xfe318000 0x10016
	$phys_mem.set 0xfe318010 0x20016
	$phys_mem.set 0xfe318020 0x30016
	$phys_mem.set 0xfe318030 0x40016
	$phys_mem.set 0xfe318040 0x50016
	$phys_mem.set 0xfe318050 0x60016
	$phys_mem.set 0xfe318060 0x70016
	$phys_mem.set 0xfe318070 0x80016
	$phys_mem.set 0xfe318080 0x90016
	$phys_mem.set 0xfe318090 0xa0016


        # Note: user must override boot_command if dev_tree_blob is set
	$con.wait-then-write "=> " "fdt move " + (hex ($flash_base + $dtb_flash_offset)) + " " + (hex $dtb_ram_addr) + " " + (hex $dtb_size) + "\n"
	if ($binary_image == "true") {
		if ($kernel_image != "") {
			$phys_mem.load-file $kernel_image $kernel_addr
		}
		$con.wait-then-write "=> " "go " + (hex $kernel_addr) + "\n"
        } else {
		$con.wait-then-write "=> " "setenv bootcmd " + $boot_command + "\n"
		$con.wait-then-write "=> " "boot\n"
	}
    }
}

# workaround for qman: disable delays for Simics 3.2.35
qman->push_interval=0
qman->enqueue_interval=0

